/**
 * @author generated by eTrice
 *
 * Dispatcher File of Node node with SubSystem subSystemRef
 * contains a generated message dispatcher (receiveMessage) for each MessageService (Thread)
 */

#include "messaging/etMessageReceiver.h"
#include "debugging/etLogger.h"
#include "debugging/etMSCLogger.h"


/**
 * generated execute function for all cyclic execute calls for the async or datadriven actor instances of thread "DefaultPhysicalThread"
 */
static void MsgDispatcher_DefaultPhysicalThread_poll(void){
	ET_MSC_LOGGER_SYNC_ENTRY("MsgDispatcher_DefaultPhysicalThread", "execute")
	ATimingService_execute((void*)&_LogSys_subSystemRef_timingService);
	ET_MSC_LOGGER_SYNC_EXIT
}

/**
 * generated dispatch function for all messages for the thread "DefaultPhysicalThread"
 */
static etBool MsgDispatcher_DefaultPhysicalThread_receiveMessage(const etMessage* msg){
	ET_MSC_LOGGER_SYNC_ENTRY("MsgDispatcher_DefaultPhysicalThread", "receiveMessage")
	switch(msg->address){

		case MESSAGESERVICE_ADDRESS:
			if (msg->evtID == etSystemProtocol_IN_poll) {
				MsgDispatcher_DefaultPhysicalThread_poll();
			}
			else
			if (msg->evtID == etSystemProtocol_IN_terminate)
				return ET_FALSE;
			break;

		/* interface items of /LogSys/subSystemRef/topActor */

		/* interface items of /LogSys/subSystemRef/topActor/TCPClient */
		case 3+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_TCPClient_const.controlPort)->peerInstName,
				PTcpControl_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_TCPClient_const.controlPort)->myInstName
				)
			ATcpClient_receiveMessage((void*)&_LogSys_subSystemRef_topActor_TCPClient,(etPort*)&_LogSys_subSystemRef_topActor_TCPClient_const.controlPort, msg);
			break;
		case 4+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_TCPClient_const.payloadPort)->peerInstName,
				PTcpPayload_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_TCPClient_const.payloadPort)->myInstName
				)
			ATcpClient_receiveMessage((void*)&_LogSys_subSystemRef_topActor_TCPClient,(etPort*)&_LogSys_subSystemRef_topActor_TCPClient_const.payloadPort, msg);
			break;

		/* interface items of /LogSys/subSystemRef/timingService */

		default:
			etLogger_logErrorF("MessageService_DefaultPhysicalThread_receiveMessage: address %d does not exist ", msg->address);
			break;
	}
	ET_MSC_LOGGER_SYNC_EXIT
	return ET_TRUE;
}



/**
 * generated dispatch function for all messages for the thread "GateThread"
 */
static etBool MsgDispatcher_GateThread_receiveMessage(const etMessage* msg){
	ET_MSC_LOGGER_SYNC_ENTRY("MsgDispatcher_GateThread", "receiveMessage")
	switch(msg->address){

		case MESSAGESERVICE_ADDRESS:
			if (msg->evtID == etSystemProtocol_IN_terminate)
				return ET_FALSE;
			break;

		/* interface items of /LogSys/subSystemRef/topActor/gateway */
		case 6+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_gateway_const.ctrl)->peerInstName,
				PTcpControl_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_gateway_const.ctrl)->myInstName
				)
			Gateway_receiveMessage((void*)&_LogSys_subSystemRef_topActor_gateway,(etPort*)&_LogSys_subSystemRef_topActor_gateway_const.ctrl, msg);
			break;
		case 7+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_gateway_const.payload)->peerInstName,
				PTcpPayload_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_gateway_const.payload)->myInstName
				)
			Gateway_receiveMessage((void*)&_LogSys_subSystemRef_topActor_gateway,(etPort*)&_LogSys_subSystemRef_topActor_gateway_const.payload, msg);
			break;
		case 8+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_gateway_const.dataPortA)->peerInstName,
				PSendData_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_gateway_const.dataPortA)->myInstName
				)
			Gateway_receiveMessage((void*)&_LogSys_subSystemRef_topActor_gateway,(etPort*)&_LogSys_subSystemRef_topActor_gateway_const.dataPortA, msg);
			break;

		default:
			etLogger_logErrorF("MessageService_GateThread_receiveMessage: address %d does not exist ", msg->address);
			break;
	}
	ET_MSC_LOGGER_SYNC_EXIT
	return ET_TRUE;
}



/**
 * generated dispatch function for all messages for the thread "ControlThread"
 */
static etBool MsgDispatcher_ControlThread_receiveMessage(const etMessage* msg){
	ET_MSC_LOGGER_SYNC_ENTRY("MsgDispatcher_ControlThread", "receiveMessage")
	switch(msg->address){

		case MESSAGESERVICE_ADDRESS:
			if (msg->evtID == etSystemProtocol_IN_terminate)
				return ET_FALSE;
			break;

		/* interface items of /LogSys/subSystemRef/topActor/controller */
		case 10+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_controller_const.dataPortB)->peerInstName,
				PSendData_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_controller_const.dataPortB)->myInstName
				)
			ADAS_Controller_receiveMessage((void*)&_LogSys_subSystemRef_topActor_controller,(etPort*)&_LogSys_subSystemRef_topActor_controller_const.dataPortB, msg);
			break;
		case 11+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_controller_const.relayPortA)->peerInstName,
				PSendData_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_controller_const.relayPortA)->myInstName
				)
			ADAS_Controller_receiveMessage((void*)&_LogSys_subSystemRef_topActor_controller,(etPort*)&_LogSys_subSystemRef_topActor_controller_const.relayPortA, msg);
			break;
		case 12+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_controller_const.relayPortB)->peerInstName,
				PSendData_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_controller_const.relayPortB)->myInstName
				)
			ADAS_Controller_receiveMessage((void*)&_LogSys_subSystemRef_topActor_controller,(etPort*)&_LogSys_subSystemRef_topActor_controller_const.relayPortB, msg);
			break;
		case 13+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_controller_const.relayPortC)->peerInstName,
				PSendData_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_controller_const.relayPortC)->myInstName
				)
			ADAS_Controller_receiveMessage((void*)&_LogSys_subSystemRef_topActor_controller,(etPort*)&_LogSys_subSystemRef_topActor_controller_const.relayPortC, msg);
			break;

		default:
			etLogger_logErrorF("MessageService_ControlThread_receiveMessage: address %d does not exist ", msg->address);
			break;
	}
	ET_MSC_LOGGER_SYNC_EXIT
	return ET_TRUE;
}



/**
 * generated dispatch function for all messages for the thread "PAEBThread"
 */
static etBool MsgDispatcher_PAEBThread_receiveMessage(const etMessage* msg){
	ET_MSC_LOGGER_SYNC_ENTRY("MsgDispatcher_PAEBThread", "receiveMessage")
	switch(msg->address){

		case MESSAGESERVICE_ADDRESS:
			if (msg->evtID == etSystemProtocol_IN_terminate)
				return ET_FALSE;
			break;

		/* interface items of /LogSys/subSystemRef/topActor/AutoEmergencyBraking */
		case 15+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_AutoEmergencyBraking_const.recvPort)->peerInstName,
				PSendData_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_AutoEmergencyBraking_const.recvPort)->myInstName
				)
			AEB_receiveMessage((void*)&_LogSys_subSystemRef_topActor_AutoEmergencyBraking,(etPort*)&_LogSys_subSystemRef_topActor_AutoEmergencyBraking_const.recvPort, msg);
			break;

		default:
			etLogger_logErrorF("MessageService_PAEBThread_receiveMessage: address %d does not exist ", msg->address);
			break;
	}
	ET_MSC_LOGGER_SYNC_EXIT
	return ET_TRUE;
}



/**
 * generated dispatch function for all messages for the thread "PACCThread"
 */
static etBool MsgDispatcher_PACCThread_receiveMessage(const etMessage* msg){
	ET_MSC_LOGGER_SYNC_ENTRY("MsgDispatcher_PACCThread", "receiveMessage")
	switch(msg->address){

		case MESSAGESERVICE_ADDRESS:
			if (msg->evtID == etSystemProtocol_IN_terminate)
				return ET_FALSE;
			break;

		/* interface items of /LogSys/subSystemRef/topActor/AdaptiveCruiseControl */
		case 17+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_AdaptiveCruiseControl_const.recvPort)->peerInstName,
				PSendData_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_AdaptiveCruiseControl_const.recvPort)->myInstName
				)
			ACC_receiveMessage((void*)&_LogSys_subSystemRef_topActor_AdaptiveCruiseControl,(etPort*)&_LogSys_subSystemRef_topActor_AdaptiveCruiseControl_const.recvPort, msg);
			break;

		default:
			etLogger_logErrorF("MessageService_PACCThread_receiveMessage: address %d does not exist ", msg->address);
			break;
	}
	ET_MSC_LOGGER_SYNC_EXIT
	return ET_TRUE;
}



/**
 * generated dispatch function for all messages for the thread "PALKThread"
 */
static etBool MsgDispatcher_PALKThread_receiveMessage(const etMessage* msg){
	ET_MSC_LOGGER_SYNC_ENTRY("MsgDispatcher_PALKThread", "receiveMessage")
	switch(msg->address){

		case MESSAGESERVICE_ADDRESS:
			if (msg->evtID == etSystemProtocol_IN_terminate)
				return ET_FALSE;
			break;

		/* interface items of /LogSys/subSystemRef/topActor/AutoLaneKeeping */
		case 19+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_AutoLaneKeeping_const.recvPort)->peerInstName,
				PSendData_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_AutoLaneKeeping_const.recvPort)->myInstName
				)
			ALK_receiveMessage((void*)&_LogSys_subSystemRef_topActor_AutoLaneKeeping,(etPort*)&_LogSys_subSystemRef_topActor_AutoLaneKeeping_const.recvPort, msg);
			break;

		default:
			etLogger_logErrorF("MessageService_PALKThread_receiveMessage: address %d does not exist ", msg->address);
			break;
	}
	ET_MSC_LOGGER_SYNC_EXIT
	return ET_TRUE;
}
